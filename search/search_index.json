{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"<code>jaf</code> - JSON Array Filter","text":"<p><code>jaf</code> is a simple, focused filtering system for JSON arrays, with added support for boolean algebra on filter results and resolving results to original data. It's designed to be not Turing-complete and focuses solely on filtering with predictable boolean results.</p>"},{"location":"#core-philosophy","title":"Core Philosophy","text":"<ul> <li>Simple: Easy to understand and debug</li> <li>Predictable: Every query returns boolean results for filtering</li> <li>Secure: No arbitrary code execution or side effects</li> <li>Focused: Designed specifically for JSON array filtering and result set manipulation</li> </ul>"},{"location":"#output-jafresultset","title":"Output: <code>JafResultSet</code>","text":"<p>The <code>jaf filter</code> command, and boolean operations, produce a <code>JafResultSet</code>. This is a JSON object containing: - <code>indices</code>: A sorted list of integers representing the indices of matched items from the original data. - <code>collection_size</code>: The total number of items in the original data collection. - <code>collection_id</code>: An identifier for the original data collection (e.g., file path, directory path, or a custom ID). - <code>filenames_in_collection</code> (optional): A sorted list of unique file paths that contributed to the collection, especially when filtering a directory.</p> <p>Example <code>JafResultSet</code> (compact JSON output): <pre><code>{\"indices\":[0,2],\"collection_size\":3,\"collection_id\":\"/path/to/data.json\",\"filenames_in_collection\":[\"/path/to/data.json\"]}\n</code></pre></p>"},{"location":"#query-format-ast","title":"Query Format (AST)","text":"<p>JAF queries use an S-expression syntax (nested lists): <code>[operator, arg1, arg2, ...]</code></p> <p>Examples:</p> <pre><code># Find objects where name is \"John\"\n[\"eq?\", [\"path\", [[\"key\", \"name\"]]], \"John\"]\n\n# Find objects where email exists AND stars are greater than 100\n[\"and\", \n  [\"exists?\", [\"path\", [[\"key\", \"email\"]]]], \n  [\"gt?\", [\"path\", [[\"key\", \"stars\"]]], 100]\n]\n</code></pre> <p>(A human-readable DSL format may be a planned feature but is not part of the core AST evaluation.)</p>"},{"location":"#path-system-tagged-ast","title":"Path System (Tagged AST)","text":"<p>At the heart of data access in JAF is its Path System. This system can be thought of as a mini-language for navigating JSON structures. Paths are represented as a list of tagged components, forming their own Abstract Syntax Tree (AST) for data traversal.</p> <p>Path Component Tags:</p> <ul> <li><code>[\"key\", &lt;string_key_name&gt;]</code>: Accesses an object property.</li> <li>Example: <code>[[\"key\", \"user\"], [\"key\", \"email\"]]</code> (for <code>obj[\"user\"][\"email\"]</code>)</li> <li><code>[\"index\", &lt;integer_index&gt;]</code>: Accesses an array element (supports negative indexing).</li> <li>Example: <code>[[\"key\", \"data\"], [\"index\", 0], [\"key\", \"value\"]]</code> (for <code>obj[\"data\"][0][\"value\"]</code>)</li> <li><code>[\"indices\", [&lt;int_idx1&gt;, ...]]</code>: Accesses multiple array elements by specific indices.</li> <li><code>[\"slice\", &lt;start_or_null&gt;, &lt;stop_or_null&gt;, &lt;step_or_null&gt;]</code>: Accesses a slice of an array (Python-like slicing, <code>null</code> can be used for defaults, e.g., <code>null</code> for <code>start</code> means from the beginning, <code>null</code> for <code>stop</code> means till the end, <code>null</code> for <code>step</code> means <code>1</code>).</li> <li><code>[\"regex_key\", &lt;pattern_string&gt;]</code>: Accesses object properties where keys match a regex.</li> <li><code>[\"wc_level\"]</code>: Wildcard for the current level.</li> <li>Example: <code>[[\"key\", \"items\"], [\"wc_level\"], [\"key\", \"name\"]]</code> (gets all names from items)</li> <li><code>[\"wc_recursive\"]</code>: Recursive wildcard.</li> <li>Example: <code>[[\"wc_recursive\"], [\"key\", \"error\"]]</code> (finds any \"error\" key at any depth)</li> <li><code>[\"root\"]</code>: Represents the root of the object being evaluated.</li> <li>Example: <code>[[\"root\"], [\"key\", \"config\"]]</code> accesses <code>obj[\"config\"]</code> assuming <code>obj</code> is the root.</li> </ul> <p>Path Evaluation (<code>eval_path</code>):</p> <p>The <code>[\"path\", path_components_list]</code> special form uses an internal <code>eval_path</code> function to resolve these path expressions against a JSON object.</p> <ul> <li>Single Value: If a path that does not contain multi-match components (like wildcards or slices) resolves to one specific value (including <code>null</code>), that value is returned directly.</li> <li>Multiple Values (<code>PathValues</code>): If a path uses components that can naturally yield multiple results (e.g., <code>indices</code>, <code>slice</code>, <code>regex_key</code>, <code>wc_level</code>, or <code>wc_recursive</code>), it returns a <code>PathValues</code> object. <code>PathValues</code> is a specialized list subclass that holds the collection of all values found by the path. It preserves the order of discovery and can contain duplicates if the data and path logic lead to them. It also provides convenience methods like <code>first()</code>, <code>one()</code>, etc.</li> <li>Not Found (Specific Path): If a path that does not contain multi-match components fails to resolve (e.g., key not found, index out of bounds for a specific index access), <code>eval_path</code> returns an empty list <code>[]</code> to signify \"not found\".</li> <li>Not Found (Multi-match Path): If a path with multi-match components finds no values, it returns an empty <code>PathValues</code> object (e.g., <code>PathValues([])</code>). This is distinct from the <code>[]</code> returned for a specific path not found.</li> <li>Empty Path: <code>[\"path\", []]</code> returns the original object.</li> </ul> <p>Wildcard/Multi-Value Path Behavior in Predicates (Existential Quantification - \u2203):</p> <p>When a path expression results in a <code>PathValues</code> object (due to wildcards, slices, etc.) and is used as an argument to a predicate:</p> <ul> <li>The predicate is <code>true</code> if at least one value (or combination of values, if multiple such paths are arguments) from the <code>PathValues</code> collection satisfies the predicate.</li> <li>Example: <code>[\"eq?\", [\"path\", [[\"key\", \"projects\"], [\"wc_level\"], [\"key\", \"status\"]]], \"completed\"]</code>   This is true if any project has its status as \"completed\".</li> </ul> <p>This \"any match is sufficient\" behavior (existential quantification) is intuitive for filtering. Universal quantification (\"for all items to match\") can often be constructed using negation and existential checks.</p>"},{"location":"#available-operators","title":"Available Operators","text":"<p>Refer to the Full Specification for a detailed list of operators. The library now includes type-checking predicates (<code>is-string?</code>, etc.), additional transformers (<code>first</code>, <code>unique</code>, etc.), the <code>self</code> operator, and variadic arithmetic operators.</p>"},{"location":"#command-line-interface-cli","title":"Command-Line Interface (CLI)","text":"<p><code>jaf</code> provides a CLI for filtering data and performing operations on result sets. See the CLI Reference for details. Key features include: - <code>jaf filter</code>: The primary filtering command. - <code>jaf &lt;and|or|...&gt;</code>: Perform boolean algebra on result sets. Can now take a <code>--query</code> argument for the second operand. - <code>jaf resolve</code>: Resolve results back to data, with powerful output options like <code>--extract-path</code> and <code>--output-json-array</code>.</p>"},{"location":"#full-specification","title":"Full Specification","text":"<p>For detailed information on all operators, path components, <code>JafResultSet</code> structure, and evaluation rules, please see the Full Specification.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code># (Assuming package is published)\n# pip install jaf\n\n# For local development:\n# git clone &lt;repository_url&gt;\n# cd jaf\n# pip install -e .[dev]\n</code></pre>"},{"location":"#usage-example-python","title":"Usage Example (Python)","text":"<pre><code>from jaf import jaf, JafResultSet\n\ndata = [\n    {\"id\": 1, \"name\": \"Alice\", \"tags\": [\"dev\", \"python\"], \"status\": \"active\"},\n    {\"id\": 2, \"name\": \"Bob\", \"tags\": [\"qa\", \"java\"], \"status\": \"inactive\"},\n    {\"id\": 3, \"name\": \"Charlie\", \"tags\": [\"dev\", \"go\"], \"status\": \"active\", \"extra\": {\"priority\": \"high\"}}\n]\n\n# Find active developers (status is \"active\" and \"dev\" is in tags)\nquery_active_devs = [\n    \"and\",\n    [\"eq?\", [\"path\", [[\"key\", \"status\"]]], \"active\"],\n    [\"in?\", \"dev\", [\"path\", [[\"key\", \"tags\"]]]]\n]\n\n# The jaf function returns a JafResultSet instance\nresult_set_active_devs: JafResultSet = jaf(data, query_active_devs, collection_id=\"my_data_v1\")\nprint(f\"Active developers JafResultSet: {result_set_active_devs}\")\nprint(f\"Indices of active developers: {list(result_set_active_devs)}\") # Iterate or convert to list\n\n# To get the actual objects:\nactive_dev_objects = [data[i] for i in result_set_active_devs.indices]\nprint(f\"Active developer objects: {active_dev_objects}\")\n\n# Example of using JafResultSet methods (programmatic boolean algebra)\nquery_python_users = [\"in?\", \"python\", [\"path\", [[\"key\", \"tags\"]]]]\nrs_python: JafResultSet = jaf(data, query_python_users, collection_id=\"my_data_v1\")\n\n# Active Python developers\nrs_active_python_devs = result_set_active_devs.AND(rs_python) # or result_set_active_devs &amp; rs_python\nprint(f\"Active Python developers (indices): {list(rs_active_python_devs)}\")\n\n# Using the get_matching_objects method (if JRS was from a file source and had metadata)\n# For this example, data is in-memory, so direct indexing is shown above.\n# If rs_active_python_devs was loaded from a file and had filenames_in_collection:\n# try:\n#   original_objects = rs_active_python_devs.get_matching_objects()\n#   print(f\"Original objects for active Python devs: {original_objects}\")\n# except JafResultSetError as e:\n#   print(f\"Could not resolve objects: {e}\")\n</code></pre>"},{"location":"cli_reference/","title":"JAF Command-Line Interface (CLI) Reference","text":"<p>This page details the usage of the <code>jaf</code> command-line tool.</p>"},{"location":"cli_reference/#global-options","title":"Global Options","text":"<p>These options apply to most <code>jaf</code> subcommands:</p> <ul> <li><code>--log-level &lt;LEVEL&gt;</code>: Set the logging level. Choices: <code>DEBUG</code>, <code>INFO</code>, <code>WARNING</code>, <code>ERROR</code>, <code>CRITICAL</code>. Default: <code>WARNING</code>.</li> <li><code>--drop-filenames</code>: For boolean operations, omit <code>filenames_in_collection</code> from the output <code>JafResultSet</code> JSON.</li> </ul>"},{"location":"cli_reference/#jaf-filter","title":"<code>jaf filter</code>","text":"<p>Filters JSON/JSONL data from a file or directory based on a JAF query.</p> <p>Usage:</p> <pre><code>jaf filter &lt;input_source&gt; --query '&lt;query_ast_json_string&gt;' [options]\n</code></pre> <p>Arguments &amp; Options:</p> <ul> <li><code>&lt;input_source&gt;</code> (required): Path to a JSON/JSONL file or a directory containing such files.</li> <li><code>--query '&lt;query_ast_json_string&gt;'</code> (required): The JAF query string, formatted as a JSON Abstract Syntax Tree (AST).<ul> <li>Example: <code>'[\"eq?\", [\"path\", [[\"key\", \"status\"]]], \"active\"]'</code></li> </ul> </li> <li><code>--recursive</code>: If <code>&lt;input_source&gt;</code> is a directory, search for data files recursively.</li> <li><code>--collection-id &lt;id&gt;</code>: Assign a custom ID to the data collection. This ID will be stored in the output <code>JafResultSet</code>. If not provided, a default ID (usually the absolute path of the input source) is used.</li> <li><code>--resolve</code>: Instead of outputting a <code>JafResultSet</code> JSON, resolve the filter results and print the actual matching JSON objects, one per line (JSONL format).</li> </ul> <p>Output:</p> <ul> <li>By default: A <code>JafResultSet</code> JSON object to <code>stdout</code>.</li> <li>With <code>--resolve</code>: A stream of matching JSON objects (JSONL) to <code>stdout</code>. Informational messages are printed to <code>stderr</code>.</li> </ul> <p>Examples:</p> <pre><code># Filter data.jsonl for items where status is \"active\", output JafResultSet\njaf filter data.jsonl --query '[\"eq?\", [\"path\", [[\"key\", \"status\"]]], \"active\"]'\n\n# Filter data_dir recursively for items where count &gt; 10, output matching objects\njaf filter data_dir --query '[\"gt?\", [\"path\", [[\"key\", \"count\"]]], 10]' --recursive --resolve\n\n# Assign a custom collection ID\njaf filter logs.jsonl --query '[\"exists?\", [\"path\", [[\"key\", \"error\"]]]]' --collection-id \"error_logs_v1\"\n</code></pre>"},{"location":"cli_reference/#result-set-operations-boolean-algebra","title":"Result Set Operations (Boolean Algebra)","text":"<p>These commands perform boolean algebra on <code>JafResultSet</code> instances. The output is always a new <code>JafResultSet</code> JSON to <code>stdout</code>.</p> <p>Operand Types: - First Operand: A <code>JafResultSet</code> provided via a file path or from <code>stdin</code> (<code>-</code>). - Second Operand (for binary ops): Can be either:     1. A second <code>JafResultSet</code> from a file path.     2. A JAF query string provided via the <code>--query</code> option. This query is executed against the data source of the first <code>JafResultSet</code>.</p> <p>General Input Handling:</p> <p>For binary operations (e.g., <code>and</code>, <code>or</code>, <code>xor</code>, <code>difference</code>): -   <code>jaf &lt;op&gt; &lt;rs1_path_or_-&gt; &lt;rs2_path_or_-&gt;</code>: Specifies both inputs. -   <code>jaf &lt;op&gt; &lt;file.json&gt;</code>: Assumes first input from <code>stdin</code>, second from <code>&lt;file.json&gt;</code>. -   <code>jaf &lt;op&gt; - &lt;file.json&gt;</code>: First input from <code>stdin</code>, second from <code>&lt;file.json&gt;</code>. -   <code>jaf &lt;op&gt; &lt;file.json&gt; -</code>: First input from <code>&lt;file.json&gt;</code>, second from <code>stdin</code>. (Less common for CLI piping)</p> <p>For unary operations (e.g., <code>not</code>): -   <code>jaf not &lt;rs_path_or_-&gt;</code>: Specifies the input. -   <code>jaf not</code>: Assumes input from <code>stdin</code>.</p> <p>It's an error to try to read both inputs from <code>stdin</code> for a binary operation.</p>"},{"location":"cli_reference/#jaf-and","title":"<code>jaf and</code>","text":"<p>Performs a logical AND (intersection).</p> <p>Usage: <pre><code># With two JafResultSet inputs\njaf and [rs1_path_or_-] [rs2_path_or_-]\n\n# With one JafResultSet and one on-the-fly query\njaf and [rs1_path_or_-] --query '&lt;query_ast_json_string&gt;'\n</code></pre></p>"},{"location":"cli_reference/#jaf-or","title":"<code>jaf or</code>","text":"<p>Performs a logical OR (union).</p> <p>Usage: <pre><code>jaf or [rs1_path_or_-] [rs2_path_or_-]\njaf or [rs1_path_or_-] --query '&lt;query_ast_json_string&gt;'\n</code></pre></p>"},{"location":"cli_reference/#jaf-not","title":"<code>jaf not</code>","text":"<p>Performs a logical NOT (complement) on a <code>JafResultSet</code>.</p> <p>Usage: <code>jaf not [rs_path_or_-]</code></p>"},{"location":"cli_reference/#jaf-xor","title":"<code>jaf xor</code>","text":"<p>Performs a logical XOR (symmetric difference).</p> <p>Usage: <pre><code>jaf xor [rs1_path_or_-] [rs2_path_or_-]\njaf xor [rs1_path_or_-] --query '&lt;query_ast_json_string&gt;'\n</code></pre></p>"},{"location":"cli_reference/#jaf-difference","title":"<code>jaf difference</code>","text":"<p>Performs a logical set difference (<code>rs1 - rs2</code>).</p> <p>Usage: <pre><code>jaf difference [rs1_path_or_-] [rs2_path_or_-]\njaf difference [rs1_path_or_-] --query '&lt;query_ast_json_string&gt;'\n</code></pre></p> <p>Boolean Operation Examples:</p> <pre><code># Create result sets\njaf filter users.jsonl --query '[\"eq?\",[\"path\",[[\"key\",\"status\"]]],\"active\"]' &gt; active.jrs\njaf filter users.jsonl --query '[\"in?\",\"dev\",[\"path\",[[\"key\",\"tags\"]]]]' &gt; devs.jrs\n\n# Active developers\njaf and active.jrs devs.jrs &gt; active_devs.jrs\n\n# Users who are active OR developers\njaf or active.jrs devs.jrs\n\n# Users who are NOT active\njaf not active.jrs\n\n# Users who are active but NOT developers\njaf difference active.jrs devs.jrs\n\n# Users who are active but NOT developers (using --query)\njaf filter users.jsonl --query '[\"eq?\", \"@status\", \"active\"]' | jaf difference --query '[\"in?\",\"dev\",\"@tags\"]'\n\n# Using stdin for the first input\ncat active.jrs | jaf and - devs.jrs\n</code></pre>"},{"location":"cli_reference/#jaf-resolve","title":"<code>jaf resolve</code>","text":"<p>Resolves a <code>JafResultSet</code> (from a file or <code>stdin</code>) back to the original data or derived values.</p> <p>Usage: <pre><code>jaf resolve [jrs_path_or_-] [options]\n</code></pre></p> <p>Arguments:</p> <ul> <li><code>[jrs_path_or_-]</code>: Path to the <code>JafResultSet</code> JSON file. If omitted or <code>-</code>, reads from <code>stdin</code>.</li> </ul> <p>Output Formatting Options:</p> <p>These options are mutually exclusive.</p> <ul> <li><code>--output-jsonl</code>: Output the results as JSONL, one object per line (this is the default behavior).</li> <li><code>--output-json-array</code>: Output the results as a single, pretty-printed JSON array.</li> <li><code>--output-indices</code>: Output a simple JSON array of the matching indices.</li> <li><code>--extract-path &lt;PATH_STR&gt;</code>: For each matching object, extract the value at the given JAF path string (e.g., <code>'@user.name'</code>).</li> <li><code>--apply-query &lt;QUERY_AST&gt;</code>: For each matching object, apply the given JAF query and print the result. The query does not need to be a predicate.</li> </ul> <p>Output:</p> <ul> <li>A stream of data to <code>stdout</code> in the format specified by the output options.</li> </ul> <p>Example:</p> <pre><code># Assuming active_devs.jrs was created by a filter or boolean operation\n# and contains metadata pointing to the original users.jsonl\njaf resolve active_devs.jrs\n# This will print the full JSON objects for each active developer.\n\n# Piping from a boolean operation\njaf and active.jrs devs.jrs | jaf resolve\n\n# Extract just the user IDs from the result\njaf resolve active_devs.jrs --extract-path '@user.id'\n\n# Apply a query to transform the results\njaf resolve active_devs.jrs --apply-query '[\"+\", \"@score\", 5]'\n\n# Output as a JSON array\njaf resolve active_devs.jrs --output-json-array\n</code></pre>"},{"location":"specification/","title":"JAF (JSON Array Filter) - Specification v1.3","text":""},{"location":"specification/#overview","title":"Overview","text":"<p>JAF is a simple, focused domain-specific language for filtering JSON arrays. It's designed to be not Turing-complete and focuses solely on filtering with predictable boolean results. It also supports boolean algebraic operations on sets of filter results.</p>"},{"location":"specification/#core-philosophy","title":"Core Philosophy","text":"<ul> <li>Simple: Easy to understand and debug</li> <li>Predictable: Every query returns boolean results for filtering</li> <li>Secure: No arbitrary code execution or side effects</li> <li>Focused: Designed specifically for JSON array filtering and result set manipulation</li> </ul>"},{"location":"specification/#data-model","title":"Data Model","text":"<p>Input to <code>jaf</code> function: <code>Array&lt;Object&gt;</code> - An array of JSON objects. Output of <code>jaf</code> function: <code>JafResultSet</code> - An object representing the filter results.</p>"},{"location":"specification/#jafresultset-object","title":"<code>JafResultSet</code> Object","text":"<p>A <code>JafResultSet</code> is a JSON-serializable object that represents the outcome of a <code>jaf</code> filter operation.</p> <p>Core Attributes:</p> <p>When serialized to JSON (e.g., by the CLI), a <code>JafResultSet</code> has the following structure:</p> <ul> <li><code>indices</code>: <code>Array&lt;Number&gt;</code> (integer)<ul> <li>A sorted list of unique, 0-based indices of the objects from the original data array that matched the query.</li> </ul> </li> <li><code>collection_size</code>: <code>Number</code> (integer)<ul> <li>The total number of items in the original data collection from which the indices were derived. This is crucial for operations like <code>NOT</code>.</li> </ul> </li> <li><code>collection_id</code>: <code>Any</code> (string, number, null, etc.)<ul> <li>An optional identifier for the original data collection. This helps ensure that boolean operations are performed between result sets derived from the same logical collection. It can be a file path, directory path, or a user-defined ID.</li> </ul> </li> <li><code>collection_source</code>: (Optional) A dictionary containing metadata about the original data source, enabling data resolution.<ul> <li><code>{\"type\": \"jsonl\", \"path\": \"/path/to/file.jsonl\"}</code></li> <li><code>{\"type\": \"json_array\", \"path\": \"/path/to/file.json\"}</code></li> <li><code>{\"type\": \"directory\", \"path\": \"/path/to/dir\", \"files\": [\"/path/to/dir/a.json\", ...]}</code></li> <li><code>{\"type\": \"buffered_stdin\", \"format\": \"jsonl\", \"content\": [...]}</code>: Used when <code>stdin</code> is piped to <code>jaf filter</code>. The content is buffered to allow for subsequent resolution in a pipe chain.</li> </ul> </li> <li><code>query</code>: (Optional) The JAF query AST that produced this result set.</li> </ul> <p>Example JSON Output (compact): <pre><code>{\"indices\":[0,2],\"collection_size\":3,\"collection_id\":\"/path/to/data_dir\",\"collection_source\":{\"type\":\"directory\",\"path\":\"/path/to/data_dir\",\"files\":[\"/path/to/data_dir/a.json\"]}}\n</code></pre> If <code>collection_source</code> is not present or <code>null</code>, it's omitted from the JSON.</p>"},{"location":"specification/#query-format","title":"Query Format","text":"<p>Queries use S-expression syntax: <code>[operator, arg1, arg2, ...]</code></p> <p>Examples:</p> <pre><code># Traditional path syntax\n[\"eq?\", [\"path\", [[\"key\", \"name\"]]], \"John\"]\n[\"and\", \n  [\"exists?\", [\"path\", [[\"key\", \"email\"]]]], \n  [\"gt?\", [\"length\", [\"path\", [[\"key\", \"items\"]]]], 5]\n]\n\n# With @ special path notation (concise)\n[\"eq?\", \"@name\", \"John\"]\n[\"and\", \n  [\"exists?\", \"@email\"], \n  [\"gt?\", [\"length\", \"@items\"], 5]\n]\n</code></pre>"},{"location":"specification/#-special-path-notation","title":"@ Special Path Notation","text":"<p>JAF provides a concise <code>@</code> syntax as an alternative to the explicit <code>[\"path\", ...]</code> form. This notation significantly reduces verbosity while maintaining full compatibility with the path system.</p> <p>Syntax Forms:</p> <ol> <li>String Format: <code>\"@path.expression\"</code></li> <li>Most concise form for simple path access</li> <li> <p>Example: <code>\"@user.name\"</code>, <code>\"@items.*.status\"</code>, <code>\"@data[0].value\"</code></p> </li> <li> <p>Explicit AST with String: <code>[\"@\", \"path.expression\"]</code></p> </li> <li>Explicit operator form using string path</li> <li> <p>Example: <code>[\"@\", \"user.name\"]</code></p> </li> <li> <p>Explicit AST with Path Components: <code>[\"@\", path_components_list]</code></p> </li> <li>Explicit operator form using tagged path components</li> <li>Example: <code>[\"@\", [[\"key\", \"user\"], [\"key\", \"name\"]]]</code></li> </ol> <p>Equivalence:</p> <p>All three forms are functionally equivalent to the traditional <code>[\"path\", ...]</code> syntax:</p> <pre><code># These are all equivalent:\n\"@user.name\"                                    # Concise string format\n[\"@\", \"user.name\"]                              # Explicit with string\n[\"@\", [[\"key\", \"user\"], [\"key\", \"name\"]]]       # Explicit with AST\n[\"path\", \"user.name\"]                           # Traditional with string\n[\"path\", [[\"key\", \"user\"], [\"key\", \"name\"]]]    # Traditional with AST\n</code></pre> <p>Usage in Queries:</p> <pre><code># Simple equality with @ syntax\n[\"eq?\", \"@status\", \"active\"]\n\n# Complex conditions\n[\"and\", \n  [\"eq?\", \"@user.status\", \"active\"],\n  [\"in?\", \"dev\", \"@user.tags\"],\n  [\"gt?\", \"@user.score\", 100]]\n\n# Existence checks\n[\"exists?\", \"@user.profile.settings\"]\n\n# With wildcards and advanced path features\n[\"eq?\", \"@projects.*.status\", \"completed\"]\n[\"gt?\", \"@items[0].price\", 50]\n[\"exists?\", \"@logs.*.error\"]\n</code></pre> <p>Benefits:</p> <ul> <li>Conciseness: <code>\"@user.name\"</code> vs <code>[\"path\", \"user.name\"]</code></li> <li>Readability: Reduces visual clutter in complex queries</li> <li>Familiarity: <code>@</code> is commonly used for references in many languages</li> <li>Full Compatibility: Works with all path features (wildcards, indexing, etc.)</li> <li>Coexistence: Traditional <code>[\"path\", ...]</code> syntax remains fully supported</li> </ul>"},{"location":"specification/#path-system","title":"Path System","text":"<p>The JAF Path System is a small, dedicated sub-language for data traversal within JSON objects. Paths are lists of tagged components used within the <code>[\"path\", path_components_list]</code> special form or the <code>@</code> notation. This tagged structure (its own AST) provides a uniform and explicit way to define how to traverse the JSON data.</p> <p>Each component in the <code>path_components_list</code> is a list itself, where the first element is a tag (string) indicating the type of path segment, and subsequent elements are arguments for that segment type.</p> <p>Supported Path Component Tags:</p> <ol> <li> <p><code>[\"key\", &lt;string_key_name&gt;]</code></p> <ul> <li>Accesses an object's property by its string key.</li> <li>Example: <code>[[\"key\", \"user\"]]</code> accesses <code>obj[\"user\"]</code>.</li> </ul> </li> <li> <p><code>[\"index\", &lt;integer_index_value&gt;]</code></p> <ul> <li>Accesses an array element by its integer index (supports negative indexing).</li> <li>Example: <code>[[\"key\", \"items\"], [\"index\", 0]]</code> accesses <code>obj[\"items\"][0]</code>.</li> </ul> </li> <li> <p><code>[\"indices\", [&lt;int_idx1&gt;, &lt;int_idx2&gt;, ...]]</code></p> <ul> <li>Accesses multiple array elements by a list of specific integer indices.</li> <li>Returns a list of values found at these indices.</li> <li>Example: <code>[[\"key\", \"tags\"], [\"indices\", [0, 2, 4]]]</code> accesses <code>obj[\"tags\"][0]</code>, <code>obj[\"tags\"][2]</code>, and <code>obj[\"tags\"][4]</code>.</li> </ul> </li> <li> <p><code>[\"slice\", &lt;start_val_or_null&gt; [, &lt;stop_val_or_null&gt; [, &lt;step_val_or_null&gt;]]]</code></p> <ul> <li>Accesses a slice of an array. The AST component will have 1, 2, or 3 values after the \"slice\" tag, corresponding to <code>start</code>, <code>stop</code>, and <code>step</code>.</li> <li><code>start_val_or_null</code>: The starting index. If <code>null</code> or omitted, defaults to the beginning of the array.</li> <li><code>stop_val_or_null</code>: The ending index (exclusive). If <code>null</code> or omitted, defaults to the end of the array.</li> <li><code>step_val_or_null</code>: The step value. If <code>null</code> or omitted, defaults to <code>1</code>. A step of <code>0</code> is invalid.</li> <li>Example ASTs:<ul> <li><code>[[\"slice\", 0, 10, 2]]</code> (explicit start, stop, step)</li> <li><code>[[\"slice\", null, 5]]</code> (start from beginning, up to 5, step 1) -&gt; equivalent to <code>[[\"slice\", null, 5, null]]</code> for evaluation</li> <li><code>[[\"slice\", 2]]</code> (start from 2, to end, step 1) -&gt; equivalent to <code>[[\"slice\", 2, null, null]]</code> for evaluation</li> </ul> </li> <li>Example from query: <code>[[\"key\", \"data\"], [\"slice\", 0, 10, 2]]</code> accesses elements from index 0 up to (but not including) 10, with a step of 2.</li> <li><code>[[\"key\", \"data\"], [\"slice\", null, 5]]</code> accesses elements from the beginning up to index 5 with a default step of 1.</li> </ul> </li> <li> <p><code>[\"regex_key\", &lt;pattern_string&gt;]</code></p> <ul> <li>Accesses object properties where keys match the given regular expression pattern.</li> <li>Returns a list of values from matching keys.</li> <li>Example: <code>[[\"regex_key\", \"^error_\\\\d+$\"]]</code> accesses values for keys like \"error_1\", \"error_2\", etc. (Note: <code>\\</code> in regex might need escaping depending on the string representation in the query).</li> </ul> </li> <li> <p><code>[\"fuzzy_key\", &lt;target_key_string&gt; [, &lt;cutoff_float&gt; [, &lt;algorithm_string&gt;]]]</code></p> <ul> <li>Accesses object properties where keys are similar to the target key using fuzzy string matching.</li> <li>Arguments:<ul> <li><code>target_key_string</code>: The key name to search for (required string).</li> <li><code>cutoff_float</code>: Minimum similarity score between 0.0 and 1.0 (optional, default: 0.6).</li> <li><code>algorithm_string</code>: Matching algorithm (optional, default: \"difflib\"). Supported: \"difflib\", \"levenshtein\", \"jaro_winkler\", \"soundex\", \"metaphone\".</li> </ul> </li> <li>Behavior: Returns a list of values from keys that meet the similarity threshold, sorted by similarity (best matches first). Exact matches are prioritized.</li> <li>Library Dependencies: Some algorithms require optional libraries (Levenshtein, jellyfish). Falls back to difflib if libraries are unavailable.</li> <li>Examples: <ul> <li><code>[[\"fuzzy_key\", \"username\"]]</code> might match \"user_name\", \"userName\", \"usr_nm\"</li> <li><code>[[\"fuzzy_key\", \"apikey\", 0.8, \"levenshtein\"]]</code> uses Levenshtein distance with high precision</li> </ul> </li> </ul> </li> <li> <p><code>[\"wc_level\"]</code> (Wildcard - Current Level)</p> <ul> <li>Matches any single field name or array index at the current level of the object or array.</li> <li>Motivation: Useful for iterating over elements of a list or values of a dictionary when the keys/indices are not known beforehand, or when an operation needs to be applied to all direct children.</li> <li>Example: <code>[[\"key\", \"tasks\"], [\"wc_level\"], [\"key\", \"status\"]]</code> accesses the \"status\" of each task in the \"tasks\" list.</li> </ul> </li> <li> <p><code>[\"wc_recursive\"]</code> (Wildcard - Recursive Descent)</p> <ul> <li>Matches any field name recursively at any depth within the current object structure. It also considers the current level for matches if the subsequent path parts align.</li> <li>Motivation: Essential for deep searches where the target data might be nested at varying or unknown depths.</li> <li>Example: <code>[[\"wc_recursive\"], [\"key\", \"error_code\"]]</code> finds any \"error_code\" field anywhere in the object.</li> </ul> </li> <li> <p><code>[\"root\"]</code></p> <ul> <li>Represents the root of the object against which the entire path expression is being evaluated.</li> <li>Allows paths to \"restart\" or reference from the top-level object, even if the current evaluation context is nested due to prior path components.</li> <li>Example: <code>[[\"key\", \"user\"], [\"root\"], [\"key\", \"config\"]]</code> - if <code>obj</code> is <code>{\"user\": {\"name\": \"A\"}, \"config\": {\"setting\": \"X\"}}</code>, this path would first go to <code>obj[\"user\"]</code>, then <code>[\"root\"]</code> would reset the context to <code>obj</code>, and <code>[\"key\", \"config\"]</code> would access <code>obj[\"config\"]</code>.</li> </ul> </li> </ol> <p>Path Evaluation (<code>eval_path</code> function):</p> <p>The <code>eval_path(obj, path_components_list)</code> function (internally used by both the <code>[\"path\", ...]</code> special form and <code>@</code> notation) evaluates the given path against the <code>obj</code>.</p> <ul> <li>Return Value:<ul> <li>If the path does not contain multi-match components (i.e., only uses <code>[\"key\", ...]</code> or <code>[\"index\", ...]</code>) and successfully resolves to a single, definite value, that value is returned directly. This includes <code>None</code> if the field exists and its value is <code>null</code>.</li> <li>If the path involves components that can naturally yield multiple values (e.g., <code>[\"indices\", ...]</code>, <code>[\"slice\", ...]</code>, <code>[\"regex_key\", ...]</code>, <code>[\"wc_level\"]</code>, <code>[\"wc_recursive\"]</code>), <code>eval_path</code> returns a <code>PathValues</code> object. <code>PathValues</code> is a specialized list subclass that holds the collection of all values found by the path. It preserves the order of discovery and can contain duplicates if the data and path logic lead to them. It offers convenience methods for accessing its contents (e.g., <code>first()</code>, <code>one()</code>).</li> <li>If a path that does not contain multi-match components fails to resolve at any point (e.g., a key not found, an index out of bounds for a specific index access), <code>eval_path</code> returns an empty list <code>[]</code>. This signifies \"not found\" or \"no value\" for a specific path.</li> <li>If a path with multi-match components finds no values, it returns an empty <code>PathValues</code> object (e.g., <code>PathValues([])</code>). This is distinct from the <code>[]</code> returned for a specific path not found.</li> <li>If the <code>path_components_list</code> is empty (e.g., <code>[\"path\", []]</code> or <code>[\"@\", \"\"]</code>), <code>eval_path</code> returns the original <code>obj</code>.</li> <li>In rare cases where a path without multi-match components unexpectedly yields multiple distinct results, <code>eval_path</code> may also wrap these results in a <code>PathValues</code> object with a warning.</li> </ul> </li> </ul> <p>Examples of Path Syntax:</p> <pre><code># Traditional syntax:\n[\"path\", [[\"key\", \"name\"]]]                    # Access a top-level key\n[\"path\", [[\"key\", \"user\"], [\"key\", \"email\"]]]  # Access a nested key\n[\"path\", [[\"key\", \"items\"], [\"wc_level\"], [\"key\", \"status\"]]]  # Wildcard access\n\n# With @ syntax (equivalent):\n\"@name\"                     # Access a top-level key\n\"@user.email\"               # Access a nested key  \n\"@items.*.status\"           # Wildcard access\n\n# Array operations:\n[\"path\", [[\"key\", \"data\"], [\"index\", 0], [\"key\", \"value\"]]]    # Traditional\n\"@data[0].value\"                                               # @ syntax\n\n# Complex path operations:\n[\"path\", [[\"key\", \"measurements\"], [\"slice\", 10, 20, null]]]   # Traditional\n\"@measurements[10:20]\"                                         # @ syntax\n\n# Multiple indices:\n[\"path\", [[\"key\", \"users\"], [\"indices\", [1, 3, 5]]]]          # Traditional\n\"@users[1,3,5]\"                                                # @ syntax\n\n# Regex matching:\n[\"path\", [[\"key\", \"logs\"], [\"regex_key\", \"session_\\\\w+\"]]]     # Traditional\n# (@ syntax uses the same string path format for regex patterns)\n</code></pre> <p>Behavior of Path Special Forms:</p> <ul> <li>When <code>[\"path\", ...]</code> or <code>@</code> forms are evaluated, they internally call <code>eval_path</code> with the current object and the provided path specification.</li> <li>The result of <code>eval_path</code> (a single value, <code>None</code>, <code>[]</code>, or a <code>PathValues</code> list) is then used as the value of the path expression in the broader JAF query.</li> </ul>"},{"location":"specification/#operator-categories","title":"Operator Categories","text":""},{"location":"specification/#1-special-forms-custom-evaluation","title":"1. Special Forms (Custom Evaluation)","text":"<ul> <li><code>path</code> - Extract values: <code>[\"path\", [[\"key\", \"field\"], [\"key\", \"subfield\"]]]</code></li> <li><code>@</code> - Concise path notation: <code>\"@field.subfield\"</code> or <code>[\"@\", path_expr]</code></li> <li><code>exists?</code> - Check existence: <code>[\"exists?\", path_expr]</code></li> <li><code>self</code> - Reference the current root object: <code>[\"self\"]</code></li> <li><code>if</code> - Conditional: <code>[\"if\", condition, true-expr, false-expr]</code></li> <li><code>and</code> - Logical AND with short-circuit: <code>[\"and\", expr1, expr2, ...]</code></li> <li><code>or</code> - Logical OR with short-circuit: <code>[\"or\", expr1, expr2, ...]</code></li> <li><code>not</code> - Logical negation: <code>[\"not\", expr]</code></li> </ul>"},{"location":"specification/#2-predicates-return-boolean","title":"2. Predicates (Return Boolean)","text":"<pre><code># Comparison\n\"eq?\", \"neq?\", \"gt?\", \"gte?\", \"lt?\", \"lte?\"\n\n# Containment / Membership\n\"in?\", \"contains?\"\n\n# String matching\n\"starts-with?\", \"ends-with?\", \"regex-match?\", \"close-match?\", \"partial-match?\"\n\n# Type checking\n\"is-string?\", \"is-number?\", \"is-list?\", \"is-dict?\", \"is-null?\", \"is-empty?\"\n</code></pre>"},{"location":"specification/#3-value-extractors-support-predicates","title":"3. Value Extractors (Support Predicates)","text":"<pre><code># Data access\n\"length\", \"type\", \"keys\", \"first\", \"last\", \"unique\"\n\n# String transformation\n\"lower-case\", \"upper-case\", \"split\", \"join\"\n\n# Arithmetic (variadic)\n\"+\", \"-\", \"*\", \"/\"\n\n# Arithmetic (binary)\n\"%\"\n\n# Date/time\n\"now\", \"date\", \"datetime\", \"date-diff\", \"days\", \"seconds\"\n</code></pre>"},{"location":"specification/#function-signatures","title":"Function Signatures","text":"<p>All functions follow this pattern:</p> <pre><code>[function-name, arg1, arg2, ...]\n</code></pre> <p>Examples:</p> <pre><code># Traditional syntax:\n[\"eq?\", [\"path\", [[\"key\", \"name\"]]], \"John\"]                    # name == \"John\"\n[\"gt?\", [\"length\", [\"path\", [[\"key\", \"items\"]]]], 5]            # len(items) &gt; 5  \n[\"starts-with?\", [\"lower-case\", [\"path\", [[\"key\", \"email\"]]]], \"admin\"]  # email.lower().startswith(\"admin\")\n\n# With @ syntax (more concise):\n[\"eq?\", \"@name\", \"John\"]                                        # name == \"John\"\n[\"gt?\", [\"length\", \"@items\"], 5]                                # len(items) &gt; 5\n[\"starts-with?\", [\"lower-case\", \"@email\"], \"admin\"]             # email.lower().startswith(\"admin\")\n</code></pre> <p>New Function Signatures: - <code>[\"self\"]</code>: Returns the entire root object being evaluated. - <code>[\"contains?\", container, item]</code>: Returns true if <code>container</code> (a list or string) contains <code>item</code>. - <code>[\"is-string?\", value]</code>, <code>[\"is-number?\", value]</code>, etc.: Type-checking predicates. - <code>[\"is-empty?\", value]</code>: Returns true if a list, string, or dict is empty, or if the value is <code>None</code>. - <code>[\"first\", list]</code>, <code>[\"last\", list]</code>: Return the first or last element of a list. - <code>[\"unique\", list]</code>: Returns a new list with duplicates removed while preserving order. - <code>[\"split\", string, delimiter]</code>, <code>[\"join\", list, delimiter]</code>: String manipulation. - <code>[\"+\", num1, num2, ...]</code>: Variadic addition. <code>(+)</code> is 0, <code>(+ a)</code> is <code>a</code>. - <code>[\"*\", num1, num2, ...]</code>: Variadic multiplication. <code>(*)</code> is 1, <code>(* a)</code> is <code>a</code>. - <code>[\"-\", num1, num2, ...]</code>: Variadic subtraction. <code>(-)</code> is 0, <code>(- a)</code> is <code>-a</code>, <code>(- a b)</code> is <code>a-b</code>. - <code>[\"/\", num1, num2, ...]</code>: Variadic division. <code>(/)</code> is an error, <code>(/ a)</code> is <code>1/a</code>, <code>(/ a b)</code> is <code>a/b</code>.</p>"},{"location":"specification/#evaluation-rules","title":"Evaluation Rules","text":""},{"location":"specification/#1-literals","title":"1. Literals","text":"<ul> <li>Strings, numbers, booleans, null are returned as-is.</li> <li><code>\"hello\"</code> \u2192 <code>\"hello\"</code></li> <li><code>42</code> \u2192 <code>42</code></li> <li><code>null</code> \u2192 <code>None</code> (in Python representation)</li> </ul>"},{"location":"specification/#2-special-forms","title":"2. Special Forms","text":"<ul> <li>Evaluated with custom logic (don't evaluate all args first).</li> <li>Handle control flow and path access.</li> <li>Both <code>path</code> and <code>@</code> are special forms that handle path evaluation.</li> </ul>"},{"location":"specification/#3-regular-functions-predicates-and-value-extractors","title":"3. Regular Functions (Predicates and Value Extractors)","text":"<ul> <li>All arguments evaluated first, then function called.</li> <li>Predictable evaluation order.</li> </ul>"},{"location":"specification/#4-pathvalues-in-predicates-and-functions-interaction-with-adapt_jaf_operator","title":"4. <code>PathValues</code> in Predicates and Functions (Interaction with <code>adapt_jaf_operator</code>)","text":"<p>When a <code>PathValues</code> object (the result of a path expression involving components like <code>wc_level</code>, <code>wc_recursive</code>, <code>indices</code>, <code>slice</code>, or <code>regex_key</code>) is used as an argument to a predicate or a value-transforming function, JAF (via the <code>adapt_jaf_operator</code> utility) employs a specific evaluation strategy. <code>PathValues</code> represents the collection of all values found by such a path.</p> <p>a. Argument Expansion (Cartesian Product):</p> <ul> <li>If one or more arguments to a function are <code>PathValues</code> lists, the system generates all possible combinations of individual values from these lists. This is equivalent to a Cartesian product.</li> <li>Arguments that are not <code>PathValues</code> lists (i.e., single values) are treated as single-element lists for this product generation.</li> <li>The underlying function (predicate or transformer) is then invoked for each unique combination of arguments derived from this expansion.</li> </ul> <p>b. Predicate Evaluation (Existential Quantification - \u2203):</p> <ul> <li>If the function being called is a predicate (typically its name ends with <code>?</code>):</li> <li>The predicate evaluates to <code>true</code> if there exists at least one combination of expanded arguments for which the predicate's condition holds.</li> <li>If all combinations evaluate to <code>false</code>, or if any <code>PathValues</code> argument was initially empty (resulting in no combinations to test), the overall predicate evaluates to <code>false</code>.</li> <li>Example: <code>[\"eq?\", [\"path\", [[\"key\", \"items\"], [\"wc_level\"], [\"key\", \"status\"]]], \"completed\"]</code> or <code>[\"eq?\", \"@items.*.status\", \"completed\"]</code>.     Let <code>S = eval_path(obj, path_expr_for_items_status)</code>. The predicate is true if \u2203 s \u2208 <code>S</code> such that <code>eq?(s, \"completed\")</code> is true.</li> <li>Type errors or attribute errors encountered during the evaluation of a specific combination for a predicate cause that particular combination to yield <code>false</code>. The overall predicate can still be <code>true</code> if another combination succeeds.</li> </ul> <p>c. Value Extractor/Transformer Evaluation:</p> <ul> <li>If the function is a value extractor or transformer:</li> <li>The function is called for each combination of arguments generated as per (4a).</li> <li>A list containing the results from all these individual function calls is collected.</li> <li>Result Aggregation:<ul> <li>If this list of results contains exactly one item, that single item is returned.</li> <li>If this list contains one item which is itself a list (e.g., <code>[[1,2,3]]</code> where the inner list was the actual return value of the function for the single combination), this inner list is \"unwrapped\" and returned (e.g., <code>[1,2,3]</code>). This rule does not apply if the single item is already a <code>PathValues</code> instance or if the outer list is a <code>PathValues</code> instance.</li> <li>Otherwise (multiple results from multiple combinations, or an empty list if no combinations were processed due to an empty <code>PathValues</code>), the collected list of results is returned (often as a <code>PathValues</code> object if multiple results arose from expansion).</li> <li>If any <code>PathValues</code> argument was empty, leading to no combinations, an empty list <code>[]</code> is typically returned by the wrapper for the value extractor.</li> </ul> </li> </ul> <p>d. Universal Quantification (<code>\u2200</code>) and <code>path</code>:</p> <ul> <li>The <code>path</code> operator (and <code>@</code> notation) itself is designed for data extraction \u2013 it gathers all values that match a given path. It does not inherently perform universal quantification (\"for all\").</li> <li>Universal quantification is a checking operation. While not directly supported by <code>path</code>, such checks can often be constructed using negation and existential quantification (e.g., \"it is NOT true that there EXISTS an item that does NOT satisfy the condition\"). For example, to check if all items in a list have <code>status == \"active\"</code>: <code>[\"not\", [\"in?\", false, [\"map\", [\"lambda\", \"x\", [\"eq?\", [\"path\", [[\"key\", \"x\"], [\"key\", \"status\"]]], \"active\"]], [\"path\", [[\"key\", \"items\"]]]]]]</code> (assuming a hypothetical <code>map</code> and <code>lambda</code> for illustration; JAF does not have these directly but similar logic can be built with <code>and</code>/<code>or</code> over known items or by checking for the non-existence of a counter-example). A simpler approach for \"all items satisfy X\" is often \"NOT (EXISTS item that does NOT satisfy X)\".</li> </ul>"},{"location":"specification/#boolean-algebra-on-result-sets","title":"Boolean Algebra on Result Sets","text":"<p>The <code>JafResultSet</code> class provides methods for performing boolean algebra. This allows combining results from multiple <code>jaf</code> filter operations.</p> <p>Motivation: -   Modularity: Build complex filters from simpler, pre-computed results. -   Clarity: Easier to express and understand intricate logic. -   Reusability: Saved result sets can be reused. -   Formal Semantics: Leverages well-understood set theory.</p> <p>Core Methods (Python <code>JafResultSet</code> class):</p> <p>Each method returns a new <code>JafResultSet</code> instance.</p> <ol> <li> <p><code>AND(self, other: 'JafResultSet') -&gt; 'JafResultSet'</code> (or <code>self &amp; other</code>)</p> <ul> <li>Performs a set intersection of <code>self.indices</code> and <code>other.indices</code>.</li> <li>Requires compatibility (see below).</li> <li>The resulting <code>collection_id</code> is <code>self.collection_id</code> if not None, else <code>other.collection_id</code>.</li> <li>The resulting <code>filenames_in_collection</code> is <code>self.filenames_in_collection</code> if not None, else <code>other.filenames_in_collection</code>.</li> </ul> </li> <li> <p><code>OR(self, other: 'JafResultSet') -&gt; 'JafResultSet'</code> (or <code>self | other</code>)</p> <ul> <li>Performs a set union of <code>self.indices</code> and <code>other.indices</code>.</li> <li>Requires compatibility.</li> <li>Metadata propagation for <code>collection_id</code> and <code>filenames_in_collection</code> is the same as <code>AND</code>.</li> </ul> </li> <li> <p><code>NOT(self) -&gt; 'JafResultSet'</code> (or <code>~self</code>)</p> <ul> <li>Calculates the complement relative to <code>self.collection_size</code>.</li> <li><code>new_indices = {0, ..., self.collection_size - 1} - self.indices</code>.</li> <li>Preserves <code>self.collection_id</code> and <code>self.filenames_in_collection</code>.</li> </ul> </li> <li> <p><code>XOR(self, other: 'JafResultSet') -&gt; 'JafResultSet'</code> (or <code>self ^ other</code>)</p> <ul> <li>Performs a set symmetric difference.</li> <li>Requires compatibility.</li> <li>Metadata propagation is the same as <code>AND</code>.</li> </ul> </li> <li> <p><code>SUBTRACT(self, other: 'JafResultSet') -&gt; 'JafResultSet'</code> (or <code>self - other</code>)</p> <ul> <li>Performs set difference (<code>self.indices - other.indices</code>).</li> <li>Requires compatibility.</li> <li>Metadata propagation is the same as <code>AND</code>.</li> </ul> </li> </ol> <p>Compatibility Check (<code>_check_compatibility</code>): Before performing binary operations (AND, OR, XOR, SUBTRACT), <code>JafResultSet</code> instances must be compatible: -   <code>collection_size</code> must be identical. -   If both <code>collection_id</code>s are not None, they must be identical. -   If these conditions are not met, a <code>JafResultSetError</code> is raised. -   Differences in <code>filenames_in_collection</code> between two compatible result sets do not raise an error but may result in the output <code>JafResultSet</code> inheriting this attribute from one of the operands (typically <code>self</code>).</p>"},{"location":"specification/#resolving-result-sets-to-original-data","title":"Resolving Result Sets to Original Data","text":"<p>The <code>JafResultSet</code> class provides a method to retrieve the original data objects corresponding to its <code>indices</code>.</p> <p><code>get_matching_objects(self) -&gt; List[Any]</code>: -   Attempts to load the original data objects. -   Data Source Determination:     1.  If <code>self.filenames_in_collection</code> (a list of file paths) is present, these files are loaded in their sorted order to reconstruct the original collection.     2.  Else, if <code>self.collection_id</code> is a string representing a path to a single existing file, that file is loaded.     3.  If neither of the above provides a loadable source, a <code>JafResultSetError</code> is raised. -   Validation: After loading, it verifies that the total number of loaded objects matches <code>self.collection_size</code>. If not, a <code>JafResultSetError</code> is raised. -   Return: A list containing the original data objects at the indices specified in <code>self.indices</code>. The objects are returned in the order of the sorted indices. -   Errors: Raises <code>JafResultSetError</code> for issues like unresolvable data sources, file not found, or data inconsistencies.</p>"},{"location":"specification/#error-handling","title":"Error Handling","text":""},{"location":"specification/#path-errors","title":"Path Errors","text":"<ul> <li>Non-existent specific paths (key not found, index out of bounds for specific index access) result in <code>eval_path</code> returning <code>[]</code> (empty list).</li> <li>A multi-match path that finds no values results in <code>eval_path</code> returning an empty <code>PathValues</code> object.</li> <li>A path to a field that exists but has a <code>null</code> value will result in <code>eval_path</code> returning <code>None</code> (if it's a specific path resolving to that <code>null</code>).</li> <li>Use <code>exists?</code> to check path existence. <code>exists?</code> returns <code>true</code> if <code>eval_path</code> for the given path expression returns anything other than an empty list <code>[]</code> (when the path is specific and not found) or an empty <code>PathValues</code> (when the path is multi-match and not found). A path to a <code>null</code> value does exist and <code>exists?</code> will return <code>true</code>.</li> </ul>"},{"location":"specification/#-notation-errors","title":"@ Notation Errors","text":"<ul> <li>Empty <code>@</code> expressions (e.g., <code>\"@\"</code>) raise <code>PathSyntaxError</code>.</li> <li>Invalid path syntax in <code>@</code> expressions (e.g., <code>\"@[invalid\"</code>) raise <code>PathSyntaxError</code> with details about the syntax error.</li> <li>Wrong argument count for the <code>@</code> operator (when used as <code>[\"@\", ...]</code>) raises <code>ValueError</code>.</li> </ul>"},{"location":"specification/#type-errors","title":"Type Errors","text":"<ul> <li>Type mismatches within predicate/function evaluations (after <code>PathValues</code> expansion) generally cause that specific evaluation instance to return <code>false</code> (for predicates) or contribute an error marker/skip (for transformers), rather than halting the entire query. The <code>adapt_jaf_operator</code> handles this gracefully.</li> <li>Invalid query structure or unknown operators raise <code>jafError</code> or <code>ValueError</code>.</li> </ul>"},{"location":"specification/#jafresultset-errors","title":"<code>JafResultSet</code> Errors","text":"<ul> <li>Attempting boolean operations on incompatible <code>JafResultSet</code> instances raises <code>JafResultSetError</code>.</li> <li>Failure to load or deserialize a <code>JafResultSet</code> (e.g., from JSON) raises <code>ValueError</code> or <code>JafResultSetError</code>.</li> <li>Failure in <code>get_matching_objects()</code> (e.g., source not found, size mismatch) raises <code>JafResultSetError</code>.</li> </ul>"},{"location":"specification/#example-queries","title":"Example Queries","text":""},{"location":"specification/#basic-filtering","title":"Basic Filtering","text":"<pre><code># Traditional syntax:\n[\"eq?\", [\"path\", [[\"key\", \"name\"]]], \"John\"]\n[\"gt?\", [\"length\", [\"path\", [[\"key\", \"items\"]]]], 5]\n\n# With @ syntax (more concise):\n[\"eq?\", \"@name\", \"John\"]\n[\"gt?\", [\"length\", \"@items\"], 5]\n</code></pre>"},{"location":"specification/#complex-conditions","title":"Complex Conditions","text":"<pre><code># Traditional syntax:\n[\"and\", \n  [\"eq?\", [\"path\", [[\"key\", \"active\"]]], true],\n  [\"exists?\", [\"path\", [[\"key\", \"email\"]]]]\n]\n\n# With @ syntax:\n[\"and\", \n  [\"eq?\", \"@active\", true],\n  [\"exists?\", \"@email\"]\n]\n\n# Case-insensitive language check with @ syntax:\n[\"eq?\", [\"lower-case\", \"@language\"], \"python\"]\n</code></pre>"},{"location":"specification/#path-system-examples","title":"Path System Examples","text":"<pre><code># Traditional syntax vs @ syntax comparisons:\n\n# Any item in \"items\" list has status \"completed\"\n[\"eq?\", [\"path\", [[\"key\", \"items\"], [\"wc_level\"], [\"key\", \"status\"]]], \"completed\"]\n[\"eq?\", \"@items.*.status\", \"completed\"]  # @ syntax\n\n# Deep search for any \"error\" field that exists\n[\"exists?\", [\"path\", [[\"wc_recursive\"], [\"key\", \"error\"]]]]\n[\"exists?\", \"@**.error\"]  # @ syntax (if recursive wildcard syntax supported)\n\n# Get names of users at specific indices 0 and 2\n[\"path\", [[\"key\", \"users\"], [\"indices\", [0, 2]], [\"key\", \"name\"]]]\n\"@users[0,2].name\"  # @ syntax\n\n# Check if any log entry with a key matching \"event_.*\" has a \"level\" of \"critical\"\n[\"eq?\", [\"path\", [[\"regex_key\", \"event_.*\"], [\"key\", \"level\"]]], \"critical\"]\n\n# Check if the first three tags include \"urgent\"\n[\"in?\", \"urgent\", [\"path\", [[\"key\", \"tags\"], [\"slice\", null, 3, null]]]]\n[\"in?\", \"urgent\", \"@tags[:3]\"]  # @ syntax\n\n# Mixed usage - both syntaxes in same query:\n[\"and\",\n  [\"eq?\", \"@status\", \"active\"],                    # @ syntax\n  [\"gt?\", [\"length\", [\"path\", [[\"key\", \"items\"]]]], 0]  # traditional syntax\n]\n</code></pre>"},{"location":"specification/#advanced--syntax-examples","title":"Advanced @ Syntax Examples","text":"<pre><code># Complex nested access:\n[\"eq?\", \"@user.profile.settings.theme\", \"dark\"]\n\n# Array indexing:\n[\"gt?\", \"@scores[0]\", 85]\n[\"eq?\", \"@data[-1].status\", \"final\"]\n\n# Wildcard operations:\n[\"exists?\", \"@projects.*.deadline\"]\n[\"in?\", \"urgent\", \"@tasks.*.priority\"]\n\n# Existence checks:\n[\"exists?\", \"@user.preferences.notifications\"]\n[\"not\", [\"exists?\", \"@temp_data\"]]\n\n# In complex boolean expressions:\n[\"or\",\n  [\"and\", [\"eq?\", \"@status\", \"active\"], [\"gt?\", \"@score\", 90]],\n  [\"and\", [\"eq?\", \"@status\", \"trial\"], [\"gt?\", \"@score\", 95]]\n]\n</code></pre>"},{"location":"specification/#design-constraints","title":"Design Constraints","text":"<ol> <li>No Turing Completeness: No loops, recursion (in query language itself), or unbounded computation.</li> <li>Filtering Focus: Designed specifically for boolean filtering operations.</li> <li>Tagged AST Paths: Uniform, explicit path component representation.</li> <li>Predictable Performance: All operations have bounded execution time relative to data size and path complexity.</li> <li>Boolean Results for Filtering: Top-level queries (or conditions in <code>if</code>, <code>and</code>, <code>or</code>) must resolve to boolean values for filtering.</li> <li>Syntax Coexistence: The <code>@</code> notation coexists with traditional <code>[\"path\", ...]</code> syntax, maintaining full backward compatibility.</li> </ol> <p>This specification defines a minimal, focused JSON filtering language that's powerful enough for real-world use cases while remaining simple and predictable. The path system, with its tagged AST and concise <code>@</code> notation, enhances both explicitness and readability. The <code>JafResultSet</code> provides a robust mechanism for working with and combining filter results.</p>"}]}