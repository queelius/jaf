// ───────────────────────────────────────────────────────────
// JAF DSL - grammar.lark   (C-style function calls only)
// Works with the current parse.py transformer.
// ───────────────────────────────────────────────────────────

// ---------- Imports / ignore ----------
%import common.WS
%import common.ESCAPED_STRING
%import common.SIGNED_NUMBER
%ignore WS
%ignore /\/\/[^\n]*/          // allow // comments

// ---------- Entry ----------
start: expr

// ---------- Boolean logic ----------
?expr: or_expr

?or_expr: and_expr
        | or_expr OR and_expr                 -> or_operation

?and_expr: not_expr
         | and_expr AND not_expr              -> and_operation

?not_expr: NOT not_expr                       -> not_operation
         | atom

// ---------- Atomic expressions ----------
?atom: comparison
     | unary_exists_expr
     | function_call
     | path                                    -> eval_path_directly_as_boolean
     | BOOLEAN
     | "(" expr ")"

// ---------- Comparison & exists ----------
comparison: value COMP_OP value                -> condition
unary_exists_expr: path "exists?"

// ---------- Values ----------
?value: path
      | function_call
      | ESCAPED_STRING
      | SIGNED_NUMBER
      | BOOLEAN
      | "null"                                 -> null_literal

// ---------- Function call (C-style) ----------
function_call: IDENTIFIER "(" [value ("," value)*] ")"

// ---------- Path ----------
path: ":" path_component ("." path_component)*
path_component: IDENTIFIER
              | INT
              | STAR
              | DOUBLESTAR

// ---------- Wildcards ----------
STAR: "*"
DOUBLESTAR: "**"

// ---------- Comparison operator token (combined) ----------
COMP_OP: EQ | NEQ | GT | GTE | LT | LTE
       | IN | STARTS_WITH | ENDS_WITH
       | REGEX_MATCH | CLOSE_MATCH | PARTIAL_MATCH

// ---------- Individual operator tokens (one per line) ----------
EQ: "eq?"
NEQ: "neq?"
GT: "gt?"
GTE: "gte?"
LT: "lt?"
LTE: "lte?"
IN: "in?"
STARTS_WITH: "starts-with?"
ENDS_WITH: "ends-with?"
REGEX_MATCH: "regex-match?"
CLOSE_MATCH: "close-match?"
PARTIAL_MATCH: "partial-match?"

// ---------- Logical operator tokens ----------
OR: /(OR|or)/
AND: /(AND|and)/
NOT: /(NOT|not)/

// ---------- Primitive tokens (priority matters!) ----------
BOOLEAN.3: "true" | "false"      // priority 3 – highest
INT.2: /[0-9]+/                  // priority 2 – beats IDENTIFIER
IDENTIFIER: /[a-zA-Z_][a-zA-Z0-9_-]*/
